# Overview for `OverlayPortal`

## Description

A widget that renders its overlay child on an [Overlay].

 The overlay child is initially hidden until [OverlayPortalController.show]
 is called on the associated [controller]. The [OverlayPortal] uses
 [overlayChildBuilder] to build its overlay child and renders it on the
 specified [Overlay] as if it was inserted using an [OverlayEntry], while it
 can depend on the same set of [InheritedWidget]s (such as [Theme]) that this
 widget can depend on.

 This widget requires an [Overlay] ancestor in the widget tree when its
 overlay child is showing. The overlay child is rendered by the [Overlay]
 ancestor, not by the widget itself. This allows the overlay child to float
 above other widgets, independent of its position in the widget tree.

 When [OverlayPortalController.hide] is called, the widget built using
 [overlayChildBuilder] will be removed from the widget tree the next time the
 widget rebuilds. Stateful descendants in the overlay child subtree may lose
 states as a result.

 
 This example uses an [OverlayPortal] to build a tooltip that becomes visible
 when the user taps on the [child] widget. There's a [DefaultTextStyle] above
 the [OverlayPortal] controlling the [TextStyle] of both the [child] widget
 and the widget [overlayChildBuilder] builds, which isn't otherwise doable if
 the tooltip was added as an [OverlayEntry].

 ** See code in examples/api/lib/widgets/overlay/overlay_portal.0.dart **
 

 ### Paint Order

 In an [Overlay], an overlay child is painted after the [OverlayEntry]
 associated with its [OverlayPortal] (that is, the [OverlayEntry] closest to
 the [OverlayPortal] in the widget tree, which usually represents the
 enclosing [Route]), and before the next [OverlayEntry].

 When an [OverlayEntry] has multiple associated [OverlayPortal]s, the paint
 order between their overlay children is the order in which
 [OverlayPortalController.show] was called. The last [OverlayPortal] to have
 called `show` gets to paint its overlay child in the foreground.

 ### Semantics

 The semantics subtree generated by the overlay child is considered attached
 to [OverlayPortal] instead of the target [Overlay]. An [OverlayPortal]'s
 semantics subtree can be dropped from the semantics tree due to invisibility
 while the overlay child is still visible (for example, when the
 [OverlayPortal] is completely invisible in a [ListView] but kept alive by
 a [KeepAlive] widget). When this happens the semantics subtree generated by
 the overlay child is also dropped, even if the overlay child is still visible
 on screen.

 
 ### Differences between [OverlayPortal] and [OverlayEntry]

 The main difference between [OverlayEntry] and [OverlayPortal] is that
 [OverlayEntry] builds its widget subtree as a child of the target [Overlay],
 while [OverlayPortal] uses [OverlayPortal.overlayChildBuilder] to build a
 child widget of itself. This allows [OverlayPortal]'s overlay child to depend
 on the same set of [InheritedWidget]s as [OverlayPortal], and it's also
 guaranteed that the overlay child will not outlive its [OverlayPortal].

 On the other hand, [OverlayPortal]'s implementation is more complex. For
 instance, it does a bit more work than a regular widget during global key
 reparenting. If the content to be shown on the [Overlay] doesn't benefit
 from being a part of [OverlayPortal]'s subtree, consider using an
 [OverlayEntry] instead.
 

 See also:

  * [OverlayEntry], an alternative API for inserting widgets into an
    [Overlay].
  * [Positioned], which can be used to size and position the overlay child in
    relation to the target [Overlay]'s boundaries.
  * [CompositedTransformFollower], which can be used to position the overlay
    child in relation to the linked [CompositedTransformTarget] widget.

## Dependencies

- StatefulWidget

## Members

- **controller**: `OverlayPortalController`
  The controller to show, hide and bring to top the overlay child.

- **overlayChildBuilder**: `WidgetBuilder`
  A [WidgetBuilder] used to build a widget below this widget in the tree,
 that renders on the closest [Overlay].

 The said widget will only be built and shown in the closest [Overlay] once
 [OverlayPortalController.show] is called on the associated [controller].
 It will be painted in front of the [OverlayEntry] closest to this widget
 in the widget tree (which is usually the enclosing [Route]).

 The built overlay child widget is inserted below this widget in the widget
 tree, allowing it to depend on [InheritedWidget]s above it, and be
 notified when the [InheritedWidget]s change.

 Unlike [child], the built overlay child can visually extend outside the
 bounds of this widget without being clipped, and receive hit-test events
 outside of this widget's bounds, as long as it does not extend outside of
 the [Overlay] on which it is rendered.

- **child**: `Widget?`
  A widget below this widget in the tree.

- **_targetRootOverlay**: `bool`
## Constructors

### Unnamed Constructor
Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
 builds on the closest [Overlay] when [OverlayPortalController.show] is
 called.

### targetsRootOverlay
Creates an [OverlayPortal] that renders the widget [overlayChildBuilder]
 builds on the root [Overlay] when [OverlayPortalController.show] is
 called.

#### Parameters

- ``: `dynamic`
- ``: `dynamic`
- ``: `dynamic`
- ``: `dynamic`
### overlayChildLayoutBuilder
Creates an [OverlayPortal] that renders the widget `overlayChildBuilder`
 builds on the closest [Overlay] when [OverlayPortalController.show] is
 called.

 Developers can use `overlayChildBuilder` to configure the overlay child
 based on the the size and the location of [OverlayPortal.child] within the
 target [Overlay], as well as the size of the [Overlay] itself. This allows
 the overlay child to, for example, always follow [OverlayPortal.child] and
 at the same time resize itself base on how close it is to the edges of
 the [Overlay].

 The `overlayChildBuilder` callback is called during layout. To ensure the
 paint transform of [OverlayPortal.child] in relation to the target
 [Overlay] is up-to-date by then, all [RenderObject]s between the
 [OverlayPortal] to the target [Overlay] must establish their paint
 transform during the layout phase, which most [RenderObject]s do. One
 exception is the [CompositedTransformFollower] widget, whose [RenderObject]
 only establishes the paint transform when composited. Putting a
 [CompositedTransformFollower] between the [OverlayPortal] and the [Overlay]
 may resulting in an incorrect child paint transform being provided to the
 `overlayChildBuilder` and will cause an assertion in debug mode.

#### Parameters

- ``: `dynamic`
- ``: `dynamic`
- ``: `dynamic`
- ``: `dynamic`
